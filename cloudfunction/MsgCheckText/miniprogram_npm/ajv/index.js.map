{"version":3,"sources":["ajv.js","cache.js","data.js","keyword.js","definition_schema.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar compileSchema = require('./compile')\n  , resolve = require('./compile/resolve')\n  , Cache = require('./cache')\n  , SchemaObject = require('./compile/schema_obj')\n  , stableStringify = require('fast-json-stable-stringify')\n  , formats = require('./compile/formats')\n  , rules = require('./compile/rules')\n  , $dataMetaSchema = require('./data')\n  , util = require('./compile/util');\n\nmodule.exports = Ajv;\n\nAjv.prototype.validate = validate;\nAjv.prototype.compile = compile;\nAjv.prototype.addSchema = addSchema;\nAjv.prototype.addMetaSchema = addMetaSchema;\nAjv.prototype.validateSchema = validateSchema;\nAjv.prototype.getSchema = getSchema;\nAjv.prototype.removeSchema = removeSchema;\nAjv.prototype.addFormat = addFormat;\nAjv.prototype.errorsText = errorsText;\n\nAjv.prototype._addSchema = _addSchema;\nAjv.prototype._compile = _compile;\n\nAjv.prototype.compileAsync = require('./compile/async');\nvar customKeyword = require('./keyword');\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.prototype.validateKeyword = customKeyword.validate;\n\nvar errorClasses = require('./compile/error_classes');\nAjv.ValidationError = errorClasses.Validation;\nAjv.MissingRefError = errorClasses.MissingRef;\nAjv.$dataMetaSchema = $dataMetaSchema;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';\n\nvar META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];\nvar META_SUPPORT_DATA = ['/properties'];\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  opts = this._opts = util.copy(opts) || {};\n  setLogger(this);\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n\n  this._cache = opts.cache || new Cache;\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules();\n  this._getId = chooseGetId(opts);\n\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  if (opts.serialize === undefined) opts.serialize = stableStringify;\n  this._metaOpts = getMetaSchemaOptions(this);\n\n  if (opts.formats) addInitialFormats(this);\n  if (opts.keywords) addInitialKeywords(this);\n  addDefaultMetaSchema(this);\n  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);\n  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});\n  addInitialSchemas(this);\n}\n\n\n\n/**\n * Validate data using schema\n * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.\n * @this   Ajv\n * @param  {String|Object} schemaKeyRef key, ref or schema object\n * @param  {Any} data to be validated\n * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n */\nfunction validate(schemaKeyRef, data) {\n  var v;\n  if (typeof schemaKeyRef == 'string') {\n    v = this.getSchema(schemaKeyRef);\n    if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n  } else {\n    var schemaObj = this._addSchema(schemaKeyRef);\n    v = schemaObj.validate || this._compile(schemaObj);\n  }\n\n  var valid = v(data);\n  if (v.$async !== true) this.errors = v.errors;\n  return valid;\n}\n\n\n/**\n * Create validating function for passed schema.\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n * @return {Function} validating function\n */\nfunction compile(schema, _meta) {\n  var schemaObj = this._addSchema(schema, undefined, _meta);\n  return schemaObj.validate || this._compile(schemaObj);\n}\n\n\n/**\n * Adds schema to the instance.\n * @this   Ajv\n * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n * @return {Ajv} this for method chaining\n */\nfunction addSchema(schema, key, _skipValidation, _meta) {\n  if (Array.isArray(schema)){\n    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);\n    return this;\n  }\n  var id = this._getId(schema);\n  if (id !== undefined && typeof id != 'string')\n    throw new Error('schema id must be string');\n  key = resolve.normalizeId(key || id);\n  checkUnique(this, key);\n  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);\n  return this;\n}\n\n\n/**\n * Add schema that will be used to validate other schemas\n * options in META_IGNORE_OPTIONS are alway set to false\n * @this   Ajv\n * @param {Object} schema schema object\n * @param {String} key optional schema key\n * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n * @return {Ajv} this for method chaining\n */\nfunction addMetaSchema(schema, key, skipValidation) {\n  this.addSchema(schema, key, skipValidation, true);\n  return this;\n}\n\n\n/**\n * Validate schema\n * @this   Ajv\n * @param {Object} schema schema to validate\n * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n * @return {Boolean} true if schema is valid\n */\nfunction validateSchema(schema, throwOrLogError) {\n  var $schema = schema.$schema;\n  if ($schema !== undefined && typeof $schema != 'string')\n    throw new Error('$schema must be a string');\n  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);\n  if (!$schema) {\n    this.logger.warn('meta-schema not available');\n    this.errors = null;\n    return true;\n  }\n  var valid = this.validate($schema, schema);\n  if (!valid && throwOrLogError) {\n    var message = 'schema is invalid: ' + this.errorsText();\n    if (this._opts.validateSchema == 'log') this.logger.error(message);\n    else throw new Error(message);\n  }\n  return valid;\n}\n\n\nfunction defaultMeta(self) {\n  var meta = self._opts.meta;\n  self._opts.defaultMeta = typeof meta == 'object'\n                            ? self._getId(meta) || meta\n                            : self.getSchema(META_SCHEMA_ID)\n                              ? META_SCHEMA_ID\n                              : undefined;\n  return self._opts.defaultMeta;\n}\n\n\n/**\n * Get compiled schema from the instance by `key` or `ref`.\n * @this   Ajv\n * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n * @return {Function} schema validating function (with property `schema`).\n */\nfunction getSchema(keyRef) {\n  var schemaObj = _getSchemaObj(this, keyRef);\n  switch (typeof schemaObj) {\n    case 'object': return schemaObj.validate || this._compile(schemaObj);\n    case 'string': return this.getSchema(schemaObj);\n    case 'undefined': return _getSchemaFragment(this, keyRef);\n  }\n}\n\n\nfunction _getSchemaFragment(self, ref) {\n  var res = resolve.schema.call(self, { schema: {} }, ref);\n  if (res) {\n    var schema = res.schema\n      , root = res.root\n      , baseId = res.baseId;\n    var v = compileSchema.call(self, schema, root, undefined, baseId);\n    self._fragments[ref] = new SchemaObject({\n      ref: ref,\n      fragment: true,\n      schema: schema,\n      root: root,\n      baseId: baseId,\n      validate: v\n    });\n    return v;\n  }\n}\n\n\nfunction _getSchemaObj(self, keyRef) {\n  keyRef = resolve.normalizeId(keyRef);\n  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n}\n\n\n/**\n * Remove cached schema(s).\n * If no parameter is passed all schemas but meta-schemas are removed.\n * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n * @this   Ajv\n * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n * @return {Ajv} this for method chaining\n */\nfunction removeSchema(schemaKeyRef) {\n  if (schemaKeyRef instanceof RegExp) {\n    _removeAllSchemas(this, this._schemas, schemaKeyRef);\n    _removeAllSchemas(this, this._refs, schemaKeyRef);\n    return this;\n  }\n  switch (typeof schemaKeyRef) {\n    case 'undefined':\n      _removeAllSchemas(this, this._schemas);\n      _removeAllSchemas(this, this._refs);\n      this._cache.clear();\n      return this;\n    case 'string':\n      var schemaObj = _getSchemaObj(this, schemaKeyRef);\n      if (schemaObj) this._cache.del(schemaObj.cacheKey);\n      delete this._schemas[schemaKeyRef];\n      delete this._refs[schemaKeyRef];\n      return this;\n    case 'object':\n      var serialize = this._opts.serialize;\n      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;\n      this._cache.del(cacheKey);\n      var id = this._getId(schemaKeyRef);\n      if (id) {\n        id = resolve.normalizeId(id);\n        delete this._schemas[id];\n        delete this._refs[id];\n      }\n  }\n  return this;\n}\n\n\nfunction _removeAllSchemas(self, schemas, regex) {\n  for (var keyRef in schemas) {\n    var schemaObj = schemas[keyRef];\n    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n      self._cache.del(schemaObj.cacheKey);\n      delete schemas[keyRef];\n    }\n  }\n}\n\n\n/* @this   Ajv */\nfunction _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n  if (typeof schema != 'object' && typeof schema != 'boolean')\n    throw new Error('schema should be object or boolean');\n  var serialize = this._opts.serialize;\n  var cacheKey = serialize ? serialize(schema) : schema;\n  var cached = this._cache.get(cacheKey);\n  if (cached) return cached;\n\n  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;\n\n  var id = resolve.normalizeId(this._getId(schema));\n  if (id && shouldAddSchema) checkUnique(this, id);\n\n  var willValidate = this._opts.validateSchema !== false && !skipValidation;\n  var recursiveMeta;\n  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))\n    this.validateSchema(schema, true);\n\n  var localRefs = resolve.ids.call(this, schema);\n\n  var schemaObj = new SchemaObject({\n    id: id,\n    schema: schema,\n    localRefs: localRefs,\n    cacheKey: cacheKey,\n    meta: meta\n  });\n\n  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;\n  this._cache.put(cacheKey, schemaObj);\n\n  if (willValidate && recursiveMeta) this.validateSchema(schema, true);\n\n  return schemaObj;\n}\n\n\n/* @this   Ajv */\nfunction _compile(schemaObj, root) {\n  if (schemaObj.compiling) {\n    schemaObj.validate = callValidate;\n    callValidate.schema = schemaObj.schema;\n    callValidate.errors = null;\n    callValidate.root = root ? root : callValidate;\n    if (schemaObj.schema.$async === true)\n      callValidate.$async = true;\n    return callValidate;\n  }\n  schemaObj.compiling = true;\n\n  var currentOpts;\n  if (schemaObj.meta) {\n    currentOpts = this._opts;\n    this._opts = this._metaOpts;\n  }\n\n  var v;\n  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }\n  catch(e) {\n    delete schemaObj.validate;\n    throw e;\n  }\n  finally {\n    schemaObj.compiling = false;\n    if (schemaObj.meta) this._opts = currentOpts;\n  }\n\n  schemaObj.validate = v;\n  schemaObj.refs = v.refs;\n  schemaObj.refVal = v.refVal;\n  schemaObj.root = v.root;\n  return v;\n\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var _validate = schemaObj.validate;\n    var result = _validate.apply(this, arguments);\n    callValidate.errors = _validate.errors;\n    return result;\n  }\n}\n\n\nfunction chooseGetId(opts) {\n  switch (opts.schemaId) {\n    case 'auto': return _get$IdOrId;\n    case 'id': return _getId;\n    default: return _get$Id;\n  }\n}\n\n/* @this   Ajv */\nfunction _getId(schema) {\n  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);\n  return schema.id;\n}\n\n/* @this   Ajv */\nfunction _get$Id(schema) {\n  if (schema.id) this.logger.warn('schema id ignored', schema.id);\n  return schema.$id;\n}\n\n\nfunction _get$IdOrId(schema) {\n  if (schema.$id && schema.id && schema.$id != schema.id)\n    throw new Error('schema $id is different from id');\n  return schema.$id || schema.id;\n}\n\n\n/**\n * Convert array of error message objects to string\n * @this   Ajv\n * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n * @param  {Object} options optional options with properties `separator` and `dataVar`.\n * @return {String} human readable string with all errors descriptions\n */\nfunction errorsText(errors, options) {\n  errors = errors || this.errors;\n  if (!errors) return 'No errors';\n  options = options || {};\n  var separator = options.separator === undefined ? ', ' : options.separator;\n  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n\n  var text = '';\n  for (var i=0; i<errors.length; i++) {\n    var e = errors[i];\n    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n  }\n  return text.slice(0, -separator.length);\n}\n\n\n/**\n * Add custom format\n * @this   Ajv\n * @param {String} name format name\n * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n * @return {Ajv} this for method chaining\n */\nfunction addFormat(name, format) {\n  if (typeof format == 'string') format = new RegExp(format);\n  this._formats[name] = format;\n  return this;\n}\n\n\nfunction addDefaultMetaSchema(self) {\n  var $dataSchema;\n  if (self._opts.$data) {\n    $dataSchema = require('./refs/data.json');\n    self.addMetaSchema($dataSchema, $dataSchema.$id, true);\n  }\n  if (self._opts.meta === false) return;\n  var metaSchema = require('./refs/json-schema-draft-07.json');\n  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);\n  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n}\n\n\nfunction addInitialSchemas(self) {\n  var optsSchemas = self._opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);\n  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);\n}\n\n\nfunction addInitialFormats(self) {\n  for (var name in self._opts.formats) {\n    var format = self._opts.formats[name];\n    self.addFormat(name, format);\n  }\n}\n\n\nfunction addInitialKeywords(self) {\n  for (var name in self._opts.keywords) {\n    var keyword = self._opts.keywords[name];\n    self.addKeyword(name, keyword);\n  }\n}\n\n\nfunction checkUnique(self, id) {\n  if (self._schemas[id] || self._refs[id])\n    throw new Error('schema with key or id \"' + id + '\" already exists');\n}\n\n\nfunction getMetaSchemaOptions(self) {\n  var metaOpts = util.copy(self._opts);\n  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)\n    delete metaOpts[META_IGNORE_OPTIONS[i]];\n  return metaOpts;\n}\n\n\nfunction setLogger(self) {\n  var logger = self._opts.logger;\n  if (logger === false) {\n    self.logger = {log: noop, warn: noop, error: noop};\n  } else {\n    if (logger === undefined) logger = console;\n    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))\n      throw new Error('logger must implement log, warn and error methods');\n    self.logger = logger;\n  }\n}\n\n\nfunction noop() {}\n","\n\n\nvar Cache = module.exports = function Cache() {\n  this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n  this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n  return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n  delete this._cache[key];\n};\n\n\nCache.prototype.clear = function Cache_clear() {\n  this._cache = {};\n};\n","\n\nvar KEYWORDS = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum',\n  'maxLength',\n  'minLength',\n  'pattern',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'maxProperties',\n  'minProperties',\n  'required',\n  'additionalProperties',\n  'enum',\n  'format',\n  'const'\n];\n\nmodule.exports = function (metaSchema, keywordsJsonPointers) {\n  for (var i=0; i<keywordsJsonPointers.length; i++) {\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    var segments = keywordsJsonPointers[i].split('/');\n    var keywords = metaSchema;\n    var j;\n    for (j=1; j<segments.length; j++)\n      keywords = keywords[segments[j]];\n\n    for (j=0; j<KEYWORDS.length; j++) {\n      var key = KEYWORDS[j];\n      var schema = keywords[key];\n      if (schema) {\n        keywords[key] = {\n          anyOf: [\n            schema,\n            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n    }\n  }\n\n  return metaSchema;\n};\n","\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = require('./dotjs/custom');\nvar definitionSchema = require('./definition_schema');\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    this.validateKeyword(definition, true);\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i=0; i<dataType.length; i++)\n        _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword\n                                  || this.compile(definitionSchema, true);\n\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError)\n    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));\n  else\n    return false;\n}\n","\n\nvar metaSchema = require('./refs/json-schema-draft-07.json');\n\nmodule.exports = {\n  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',\n  definitions: {\n    simpleTypes: metaSchema.definitions.simpleTypes\n  },\n  type: 'object',\n  dependencies: {\n    schema: ['validate'],\n    $data: ['validate'],\n    statements: ['inline'],\n    valid: {not: {required: ['macro']}}\n  },\n  properties: {\n    type: metaSchema.properties.type,\n    schema: {type: 'boolean'},\n    statements: {type: 'boolean'},\n    dependencies: {\n      type: 'array',\n      items: {type: 'string'}\n    },\n    metaSchema: {type: 'object'},\n    modifying: {type: 'boolean'},\n    valid: {type: 'boolean'},\n    $data: {type: 'boolean'},\n    async: {type: 'boolean'},\n    errors: {\n      anyOf: [\n        {type: 'boolean'},\n        {const: 'full'}\n      ]\n    }\n  }\n};\n"]}